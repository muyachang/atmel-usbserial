   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  11               	.global	CALLBACK_USB_GetDescriptor
  13               	CALLBACK_USB_GetDescriptor:
  14               	.LFB67:
  15               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2010.
   4:Descriptors.c ****               
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****       www.fourwalledcubicle.com
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this 
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in 
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting 
  17:Descriptors.c ****   documentation, and that the name of the author not be used in 
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the 
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special 
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.  
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /* On some devices, there is a factory set internal serial number which can be automatically sent t
  41:Descriptors.c ****  * the device's serial number when the Device Descriptor's .SerialNumStrIndex entry is set to USE_I
  42:Descriptors.c ****  * This allows the host to track a device across insertions on different ports, allowing them to re
  43:Descriptors.c ****  * resources like COM port numbers and drivers. On demos using this feature, give a warning on unsu
  44:Descriptors.c ****  * so that the user can supply their own serial number descriptor instead or remove the USE_INTERNA
  45:Descriptors.c ****  * from the Device Descriptor (forcing the host to generate a serial number for each device from th
  46:Descriptors.c ****  * port location).
  47:Descriptors.c ****  */
  48:Descriptors.c **** #if (USE_INTERNAL_SERIAL == NO_DESCRIPTOR)
  49:Descriptors.c ****   #warning USE_INTERNAL_SERIAL is not available on this AVR - please manually construct a device se
  50:Descriptors.c **** #endif
  51:Descriptors.c **** 
  52:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  53:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  54:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  55:Descriptors.c ****  *  process begins.
  56:Descriptors.c ****  */
  57:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  58:Descriptors.c **** {
  59:Descriptors.c ****   .Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  60:Descriptors.c ****     
  61:Descriptors.c ****   .USBSpecification       = VERSION_BCD(01.10),
  62:Descriptors.c ****   .Class                  = 0x02,
  63:Descriptors.c ****   .SubClass               = 0x00,
  64:Descriptors.c ****   .Protocol               = 0x00,
  65:Descriptors.c ****         
  66:Descriptors.c ****   .Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  67:Descriptors.c ****     
  68:Descriptors.c ****   .VendorID               = 0x03EB, // Atmel
  69:Descriptors.c **** 
  70:Descriptors.c ****   .ProductID              = 0x204B, // LUFA USB to Serial Demo Application
  71:Descriptors.c ****   .ReleaseNumber          = 0x0001,
  72:Descriptors.c ****     
  73:Descriptors.c ****   .ManufacturerStrIndex   = 0x01,
  74:Descriptors.c ****   .ProductStrIndex        = 0x02,
  75:Descriptors.c ****   .SerialNumStrIndex      = USE_INTERNAL_SERIAL,
  76:Descriptors.c ****     
  77:Descriptors.c ****   .NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
  78:Descriptors.c **** };
  79:Descriptors.c **** 
  80:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
  81:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
  82:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
  83:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
  84:Descriptors.c ****  */
  85:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
  86:Descriptors.c **** {
  87:Descriptors.c ****   .Config = 
  88:Descriptors.c ****     {
  89:Descriptors.c ****       .Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTY
  90:Descriptors.c **** 
  91:Descriptors.c ****       .TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
  92:Descriptors.c ****       .TotalInterfaces        = 2,
  93:Descriptors.c ****         
  94:Descriptors.c ****       .ConfigurationNumber    = 1,
  95:Descriptors.c ****       .ConfigurationStrIndex  = NO_DESCRIPTOR,
  96:Descriptors.c ****         
  97:Descriptors.c ****       .ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
  98:Descriptors.c ****       
  99:Descriptors.c ****       .MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 100:Descriptors.c ****     },
 101:Descriptors.c ****     
 102:Descriptors.c ****   .CDC_CCI_Interface = 
 103:Descriptors.c ****     {
 104:Descriptors.c ****       .Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interfac
 105:Descriptors.c **** 
 106:Descriptors.c ****       .InterfaceNumber        = 0,
 107:Descriptors.c ****       .AlternateSetting       = 0,
 108:Descriptors.c ****       
 109:Descriptors.c ****       .TotalEndpoints         = 1,
 110:Descriptors.c ****         
 111:Descriptors.c ****       .Class                  = 0x02,
 112:Descriptors.c ****       .SubClass               = 0x02,
 113:Descriptors.c ****       .Protocol               = 0x01,
 114:Descriptors.c ****         
 115:Descriptors.c ****       .InterfaceStrIndex      = NO_DESCRIPTOR
 116:Descriptors.c ****     },
 117:Descriptors.c **** 
 118:Descriptors.c ****   .CDC_Functional_IntHeader = 
 119:Descriptors.c ****     {
 120:Descriptors.c ****       .Header                 = {.Size = sizeof(CDC_FUNCTIONAL_DESCRIPTOR(2)), .Type = 0x24},
 121:Descriptors.c ****       .SubType                = 0x00,
 122:Descriptors.c ****       
 123:Descriptors.c ****       .Data                   = {0x01, 0x10}
 124:Descriptors.c ****     },
 125:Descriptors.c **** 
 126:Descriptors.c ****   .CDC_Functional_AbstractControlManagement = 
 127:Descriptors.c ****     {
 128:Descriptors.c ****       .Header                 = {.Size = sizeof(CDC_FUNCTIONAL_DESCRIPTOR(1)), .Type = 0x24},
 129:Descriptors.c ****       .SubType                = 0x02,
 130:Descriptors.c ****       
 131:Descriptors.c ****       .Data                   = {0x06}
 132:Descriptors.c ****     },
 133:Descriptors.c ****     
 134:Descriptors.c ****   .CDC_Functional_Union = 
 135:Descriptors.c ****     {
 136:Descriptors.c ****       .Header                 = {.Size = sizeof(CDC_FUNCTIONAL_DESCRIPTOR(2)), .Type = 0x24},
 137:Descriptors.c ****       .SubType                = 0x06,
 138:Descriptors.c ****       
 139:Descriptors.c ****       .Data                   = {0x00, 0x01}
 140:Descriptors.c ****     },
 141:Descriptors.c **** 
 142:Descriptors.c ****   .CDC_NotificationEndpoint = 
 143:Descriptors.c ****     {
 144:Descriptors.c ****       .Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint}
 145:Descriptors.c ****       
 146:Descriptors.c ****       .EndpointAddress        = (ENDPOINT_DESCRIPTOR_DIR_IN | CDC_NOTIFICATION_EPNUM),
 147:Descriptors.c ****       .Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 148:Descriptors.c ****       .EndpointSize           = CDC_NOTIFICATION_EPSIZE,
 149:Descriptors.c ****       .PollingIntervalMS      = 0xFF
 150:Descriptors.c ****     },
 151:Descriptors.c **** 
 152:Descriptors.c ****   .CDC_DCI_Interface = 
 153:Descriptors.c ****     {
 154:Descriptors.c ****       .Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interfac
 155:Descriptors.c **** 
 156:Descriptors.c ****       .InterfaceNumber        = 1,
 157:Descriptors.c ****       .AlternateSetting       = 0,
 158:Descriptors.c ****       
 159:Descriptors.c ****       .TotalEndpoints         = 2,
 160:Descriptors.c ****         
 161:Descriptors.c ****       .Class                  = 0x0A,
 162:Descriptors.c ****       .SubClass               = 0x00,
 163:Descriptors.c ****       .Protocol               = 0x00,
 164:Descriptors.c ****         
 165:Descriptors.c ****       .InterfaceStrIndex      = NO_DESCRIPTOR
 166:Descriptors.c ****     },
 167:Descriptors.c **** 
 168:Descriptors.c ****   .CDC_DataOutEndpoint = 
 169:Descriptors.c ****     {
 170:Descriptors.c ****       .Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint}
 171:Descriptors.c ****       
 172:Descriptors.c ****       .EndpointAddress        = (ENDPOINT_DESCRIPTOR_DIR_OUT | CDC_RX_EPNUM),
 173:Descriptors.c ****       .Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 174:Descriptors.c ****       .EndpointSize           = CDC_TXRX_EPSIZE,
 175:Descriptors.c ****       .PollingIntervalMS      = 0x01
 176:Descriptors.c ****     },
 177:Descriptors.c ****     
 178:Descriptors.c ****   .CDC_DataInEndpoint = 
 179:Descriptors.c ****     {
 180:Descriptors.c ****       .Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint}
 181:Descriptors.c ****       
 182:Descriptors.c ****       .EndpointAddress        = (ENDPOINT_DESCRIPTOR_DIR_IN | CDC_TX_EPNUM),
 183:Descriptors.c ****       .Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 184:Descriptors.c ****       .EndpointSize           = CDC_TXRX_EPSIZE,
 185:Descriptors.c ****       .PollingIntervalMS      = 0x01
 186:Descriptors.c ****     }
 187:Descriptors.c **** };
 188:Descriptors.c **** 
 189:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 190:Descriptors.c **** {
 191:Descriptors.c ****   .Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 192:Descriptors.c ****   .UnicodeString          = {LANGUAGE_ID_ENG}
 193:Descriptors.c **** };
 194:Descriptors.c **** 
 195:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 196:Descriptors.c **** {
 197:Descriptors.c ****   .Header        = {.Size = USB_STRING_LEN(5), .Type = DTYPE_String},
 198:Descriptors.c ****   .UnicodeString = L"ICSRL"
 199:Descriptors.c **** };
 200:Descriptors.c **** 
 201:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 202:Descriptors.c **** {
 203:Descriptors.c ****   .Header        = {.Size = USB_STRING_LEN(19), .Type = DTYPE_String},
 204:Descriptors.c ****   .UnicodeString = L"ICSRL RRAM Testchip"
 205:Descriptors.c **** };
 206:Descriptors.c **** 
 207:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 208:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 209:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 210:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 211:Descriptors.c ****  *  USB host.
 212:Descriptors.c ****  */
 213:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 214:Descriptors.c ****                                     const uint8_t wIndex,
 215:Descriptors.c ****                                     const void** const DescriptorAddress)
 216:Descriptors.c **** {
  16               		.loc 1 216 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 217:Descriptors.c ****   const uint8_t  DescriptorType   = (wValue >> 8);
 218:Descriptors.c ****   const uint8_t  DescriptorNumber = (wValue & 0xFF);
 219:Descriptors.c **** 
 220:Descriptors.c ****   void*    Address = NULL;
 221:Descriptors.c ****   uint16_t Size    = NO_DESCRIPTOR;
 222:Descriptors.c **** 
 223:Descriptors.c ****   switch (DescriptorType)
  23               		.loc 1 223 0
  24 0000 292F      		mov r18,r25
  25 0002 3327      		clr r19
  26 0004 2230      		cpi r18,2
  27 0006 3105      		cpc r19,__zero_reg__
  28 0008 01F0      		breq .L3
  29 000a 2330      		cpi r18,3
  30 000c 3105      		cpc r19,__zero_reg__
  31 000e 01F0      		breq .L4
  32 0010 2130      		cpi r18,1
  33 0012 3105      		cpc r19,__zero_reg__
  34 0014 01F4      		brne .L12
 224:Descriptors.c ****   {
 225:Descriptors.c ****     case DTYPE_Device: 
 226:Descriptors.c ****       Address = (void*)&DeviceDescriptor;
 227:Descriptors.c ****       Size    = sizeof(USB_Descriptor_Device_t);
  35               		.loc 1 227 0
  36 0016 82E1      		ldi r24,lo8(18)
  37 0018 90E0      		ldi r25,0
  38               	.LVL1:
 226:Descriptors.c ****       Size    = sizeof(USB_Descriptor_Device_t);
  39               		.loc 1 226 0
  40 001a 20E0      		ldi r18,lo8(DeviceDescriptor)
  41 001c 30E0      		ldi r19,hi8(DeviceDescriptor)
  42 001e 00C0      		rjmp .L2
  43               	.LVL2:
  44               	.L3:
 228:Descriptors.c ****       break;
 229:Descriptors.c ****     case DTYPE_Configuration: 
 230:Descriptors.c ****       Address = (void*)&ConfigurationDescriptor;
 231:Descriptors.c ****       Size    = sizeof(USB_Descriptor_Configuration_t);
  45               		.loc 1 231 0
  46 0020 8EE3      		ldi r24,lo8(62)
  47 0022 90E0      		ldi r25,0
  48               	.LVL3:
 230:Descriptors.c ****       Size    = sizeof(USB_Descriptor_Configuration_t);
  49               		.loc 1 230 0
  50 0024 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  51 0026 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 232:Descriptors.c ****       break;
  52               		.loc 1 232 0
  53 0028 00C0      		rjmp .L2
  54               	.LVL4:
  55               	.L4:
 233:Descriptors.c ****     case DTYPE_String: 
 234:Descriptors.c ****       switch (DescriptorNumber)
  56               		.loc 1 234 0
  57 002a 9927      		clr r25
  58               	.LVL5:
  59 002c 8130      		cpi r24,1
  60 002e 9105      		cpc r25,__zero_reg__
  61 0030 01F0      		breq .L6
  62 0032 00F0      		brlo .L7
  63 0034 0297      		sbiw r24,2
  64 0036 01F4      		brne .L12
  65               	.LVL6:
  66               	.LBB2:
 235:Descriptors.c ****       {
 236:Descriptors.c ****         case 0x00: 
 237:Descriptors.c ****           Address = (void*)&LanguageString;
 238:Descriptors.c ****           Size    = pgm_read_byte(&LanguageString.Header.Size);
 239:Descriptors.c ****           break;
 240:Descriptors.c ****         case 0x01: 
 241:Descriptors.c ****           Address = (void*)&ManufacturerString;
 242:Descriptors.c ****           Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 243:Descriptors.c ****           break;
 244:Descriptors.c ****         case 0x02: 
 245:Descriptors.c ****           Address = (void*)&ProductString;
 246:Descriptors.c ****           Size    = pgm_read_byte(&ProductString.Header.Size);
  67               		.loc 1 246 0
  68 0038 E0E0      		ldi r30,lo8(ProductString)
  69 003a F0E0      		ldi r31,hi8(ProductString)
  70 003c 00C0      		rjmp .L13
  71               	.LVL7:
  72               	.L7:
  73               	.LBE2:
  74               	.LBB3:
 238:Descriptors.c ****           break;
  75               		.loc 1 238 0
  76 003e E0E0      		ldi r30,lo8(LanguageString)
  77 0040 F0E0      		ldi r31,hi8(LanguageString)
  78 0042 00C0      		rjmp .L13
  79               	.LVL8:
  80               	.L6:
  81               	.LBE3:
  82               	.LBB4:
 242:Descriptors.c ****           break;
  83               		.loc 1 242 0
  84 0044 E0E0      		ldi r30,lo8(ManufacturerString)
  85 0046 F0E0      		ldi r31,hi8(ManufacturerString)
  86               	.LVL9:
  87               	.L13:
  88               	.LBE4:
  89               	.LBB5:
  90               		.loc 1 246 0
  91               	/* #APP */
  92               	 ;  246 "Descriptors.c" 1
  93 0048 8491      		lpm r24, Z
  94               		
  95               	 ;  0 "" 2
  96               	.LVL10:
  97               	/* #NOAPP */
  98               	.LBE5:
  99 004a 90E0      		ldi r25,0
 100               	.LVL11:
 245:Descriptors.c ****           Size    = pgm_read_byte(&ProductString.Header.Size);
 101               		.loc 1 245 0
 102 004c 9F01      		movw r18,r30
 247:Descriptors.c ****           break;
 103               		.loc 1 247 0
 104 004e 00C0      		rjmp .L2
 105               	.LVL12:
 106               	.L12:
 221:Descriptors.c **** 
 107               		.loc 1 221 0
 108 0050 80E0      		ldi r24,0
 109 0052 90E0      		ldi r25,0
 220:Descriptors.c ****   uint16_t Size    = NO_DESCRIPTOR;
 110               		.loc 1 220 0
 111 0054 20E0      		ldi r18,0
 112 0056 30E0      		ldi r19,0
 113               	.LVL13:
 114               	.L2:
 248:Descriptors.c ****       }
 249:Descriptors.c ****       
 250:Descriptors.c ****       break;
 251:Descriptors.c ****   }
 252:Descriptors.c ****   
 253:Descriptors.c ****   *DescriptorAddress = Address;
 115               		.loc 1 253 0
 116 0058 FA01      		movw r30,r20
 117 005a 3183      		std Z+1,r19
 118 005c 2083      		st Z,r18
 254:Descriptors.c ****   return Size;
 255:Descriptors.c **** }
 119               		.loc 1 255 0
 120 005e 0895      		ret
 121               		.cfi_endproc
 122               	.LFE67:
 124               	.global	ProductString
 125               		.section	.progmem.data,"a",@progbits
 128               	ProductString:
 129 0000 28        		.byte	40
 130 0001 03        		.byte	3
 131 0002 4900      		.string	"I"
 132 0004 4300      		.string	"C"
 133 0006 5300      		.string	"S"
 134 0008 5200      		.string	"R"
 135 000a 4C00      		.string	"L"
 136 000c 2000      		.string	" "
 137 000e 5200      		.string	"R"
 138 0010 5200      		.string	"R"
 139 0012 4100      		.string	"A"
 140 0014 4D00      		.string	"M"
 141 0016 2000      		.string	" "
 142 0018 5400      		.string	"T"
 143 001a 6500      		.string	"e"
 144 001c 7300      		.string	"s"
 145 001e 7400      		.string	"t"
 146 0020 6300      		.string	"c"
 147 0022 6800      		.string	"h"
 148 0024 6900      		.string	"i"
 149 0026 7000      		.string	"p"
 150 0028 00        		.string	""
 151 0029 00        		.string	""
 152               	.global	ManufacturerString
 155               	ManufacturerString:
 156 002a 0C        		.byte	12
 157 002b 03        		.byte	3
 158 002c 4900      		.string	"I"
 159 002e 4300      		.string	"C"
 160 0030 5300      		.string	"S"
 161 0032 5200      		.string	"R"
 162 0034 4C00      		.string	"L"
 163 0036 00        		.string	""
 164 0037 00        		.string	""
 165               	.global	LanguageString
 168               	LanguageString:
 169 0038 04        		.byte	4
 170 0039 03        		.byte	3
 171 003a 0904      		.word	1033
 172               	.global	ConfigurationDescriptor
 175               	ConfigurationDescriptor:
 176 003c 09        		.byte	9
 177 003d 02        		.byte	2
 178 003e 3E00      		.word	62
 179 0040 02        		.byte	2
 180 0041 01        		.byte	1
 181 0042 00        		.byte	0
 182 0043 C0        		.byte	-64
 183 0044 32        		.byte	50
 184 0045 09        		.byte	9
 185 0046 04        		.byte	4
 186 0047 00        		.byte	0
 187 0048 00        		.byte	0
 188 0049 01        		.byte	1
 189 004a 02        		.byte	2
 190 004b 02        		.byte	2
 191 004c 01        		.byte	1
 192 004d 00        		.byte	0
 193 004e 05        		.byte	5
 194 004f 24        		.byte	36
 195 0050 00        		.byte	0
 196 0051 01        		.byte	1
 197 0052 10        		.byte	16
 198 0053 04        		.byte	4
 199 0054 24        		.byte	36
 200 0055 02        		.byte	2
 201 0056 06        		.byte	6
 202 0057 05        		.byte	5
 203 0058 24        		.byte	36
 204 0059 06        		.byte	6
 205 005a 00        		.byte	0
 206 005b 01        		.byte	1
 207 005c 07        		.byte	7
 208 005d 05        		.byte	5
 209 005e 82        		.byte	-126
 210 005f 03        		.byte	3
 211 0060 0800      		.word	8
 212 0062 FF        		.byte	-1
 213 0063 09        		.byte	9
 214 0064 04        		.byte	4
 215 0065 01        		.byte	1
 216 0066 00        		.byte	0
 217 0067 02        		.byte	2
 218 0068 0A        		.byte	10
 219 0069 00        		.byte	0
 220 006a 00        		.byte	0
 221 006b 00        		.byte	0
 222 006c 07        		.byte	7
 223 006d 05        		.byte	5
 224 006e 04        		.byte	4
 225 006f 02        		.byte	2
 226 0070 4000      		.word	64
 227 0072 01        		.byte	1
 228 0073 07        		.byte	7
 229 0074 05        		.byte	5
 230 0075 83        		.byte	-125
 231 0076 02        		.byte	2
 232 0077 4000      		.word	64
 233 0079 01        		.byte	1
 234               	.global	DeviceDescriptor
 237               	DeviceDescriptor:
 238 007a 12        		.byte	18
 239 007b 01        		.byte	1
 240 007c 1001      		.word	272
 241 007e 02        		.byte	2
 242 007f 00        		.byte	0
 243 0080 00        		.byte	0
 244 0081 08        		.byte	8
 245 0082 EB03      		.word	1003
 246 0084 4B20      		.word	8267
 247 0086 0100      		.word	1
 248 0088 01        		.byte	1
 249 0089 02        		.byte	2
 250 008a DC        		.byte	-36
 251 008b 01        		.byte	1
 252               		.text
 253               	.Letext0:
 254               		.file 2 "/nethome/mchang87/Projects/RRAM/atmega16u2/avr8-gnu-toolchain-linux_x86_64/avr/include/st
 255               		.file 3 "/nethome/mchang87/Projects/RRAM/atmega16u2/avr8-gnu-toolchain-linux_x86_64/lib/gcc/avr/5.
 256               		.file 4 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/../HighLevel/StdDescriptors.h"
 257               		.file 5 "Descriptors.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/ccjRT5Zb.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccjRT5Zb.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccjRT5Zb.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccjRT5Zb.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccjRT5Zb.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccjRT5Zb.s:13     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/ccjRT5Zb.s:237    .progmem.data:000000000000007a DeviceDescriptor
     /tmp/ccjRT5Zb.s:175    .progmem.data:000000000000003c ConfigurationDescriptor
     /tmp/ccjRT5Zb.s:128    .progmem.data:0000000000000000 ProductString
     /tmp/ccjRT5Zb.s:168    .progmem.data:0000000000000038 LanguageString
     /tmp/ccjRT5Zb.s:155    .progmem.data:000000000000002a ManufacturerString

NO UNDEFINED SYMBOLS
